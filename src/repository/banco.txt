DROP database projeto;

create database projeto;

use projeto;

CREATE TABLE tbl_cliente (
	id_cliente int(11) primary key auto_increment not null,
    nome varchar(45) not null,
    cpf varchar(14) not null,
    nascimento DATE ,
    sexo char(1) not null,
    telefone varchar(45) not null,
    email varchar(45) not null,
    cliente_deletado boolean default 0  
    );

CREATE TABLE tbl_animal (
	id_animal int (11) primary key auto_increment,
    nome_animal VARCHAr(45) not null,
    especie varchar(45) not null,
    sexo varchar(45) not null,
    nascimento date,
    peso int(11) not null,
    fk_id_cliente int(11),
    animal_deletado boolean default 0,
    constraint fk_id_cliente foreign key (fk_id_cliente) references tbl_cliente(id_cliente)
    );

CREATE TABLE tbl_servico(
	id_servico int(11) primary key auto_increment,
    descricao varchar(45) not null,
    valor_servico decimal(6,2) not null,
    tempo_servico time,
    servico_deletado boolean default 0
);

CREATE TABLE tbl_animal_servico(  
	data_servico DATETIME,
    fk_id_animal int(11),
    fk_id_servico int(11),
    
    constraint fk_id_animal foreign key (fk_id_animal) references tbl_animal (id_animal),
    constraint fk_id_servico foreign key (fk_id_servico) references tbl_servico(id_servico)
);

CREATE TABLE tbl_funcionario ( 
	id_funcionario int(11) primary key auto_increment,
    nome varchar(45) not null,
    cpf varchar(14) not null,
    funcionario_deletado boolean default 0
);

CREATE TABLE tbl_servico_funcionario (	
	fk_id_servico_funcionario int(11),
    fk_id_funcionario int(11),
    servico_deletado_funcionario boolean default 0,
    
    constraint fk_id_servico_funcionario foreign key (fk_id_servico_funcionario) references tbl_servico (id_servico),
	constraint fk_id_funcionario foreign key (fk_id_funcionario) references tbl_funcionario (id_funcionario)
);

CREATE TABLE tbl_compra(	
	id_compra int(11) primary key auto_increment,
    valor_total decimal(7,2) not null,
    data_atual DATETIME default now(),
    fk_id_cliente_compra int(11),
    fk_id_funcionario_compra int(11),
    compra_deletada boolean default 0,
    
    constraint fk_id_cliente_compra foreign key (fk_id_cliente_compra) references tbl_cliente(id_cliente),
	constraint fk_id_funcionario_compra foreign key (fk_id_funcionario_compra) references tbl_funcionario(id_funcionario)
);

############ AGORA VOU FAZER AS PROCEDURES ##################################
## (INSERT) PROCEDURE CLIENTE

delimiter $$
CREATE PROCEDURE sp_insere_cliente (p_nome varchar(45), p_cpf varchar(11) , p_nascimento date , p_sexo varchar (2) , p_telefone varchar (10) , p_email varchar(25)) 
begin
	insert into tbl_cliente(nome, cpf, nascimento, sexo, telefone, email)
		VALUES(
		p_nome, 
		p_cpf, 
		p_nascimento, 
		p_sexo , 
		p_telefone,  
		p_email 
		);
        select * from tbl_cliente where cpf = p_cpf; # AQUI ESTA MOSTRANDO PRO FUNCIONARIO, QUAL CLIENTE EU INSERI ==> COMO SE FOSSE UMA CONFERENCIA
end $$ 
delimiter ;

## TESTANDO A PROCEDURE INSERT CLIENTE
select * from tbl_cliente;

call sp_insere_cliente ("renato","458248-844","2021/05/22","M","5748-4689","silvafr@gmail.com");
call sp_insere_cliente ("julia","2435430-24","2011/08/12","F","3328-5389","julia@gmail.com");

##### ======================= ++ LOG PARA GUARDAR O UPDATE DOS CLIENTES ANTIGOS ++ ============================######### 
CREATE TABLE tbl_log_update_cliente(
    id_log_cliente int primary key auto_increment,
    cpf_log_cliente varchar(25) not null,
	nome_log_cliente varchar (35) not null, 
	nascimento_log_cliente date not null,  
	sexo_log_cliente char(1) not null,
	telefone_log_cliente varchar (20) not null,
	email_log_cliente varchar (30) not null,
    dt_alteracao datetime default now(),
    FK_log_id_cliente int not null,
    constraint FK_log_id_cliente foreign key (FK_log_id_cliente) references tbl_cliente(id_cliente) 
);

select * from tbl_log_update_cliente;

### ################ AGORA FALTA CRIAR UMA TRIGGER Q VAI COLOCAR OS CLIENTES ANTIGOS antes de ser atualizados NESSA TABELA ACIMA 
DELIMITER $
    CREATE TRIGGER trg_clientes_antigos before update on tbl_cliente
    FOR EACH ROW
        BEGIN
            INSERT INTO tbl_log_update_cliente(FK_log_id_cliente , cpf_log_cliente , nome_log_cliente , nascimento_log_cliente , sexo_log_cliente , telefone_log_cliente , email_log_cliente , dt_alteracao)
            VALUES(OLD.id_cliente, OLD.cpf , OLD.nome , OLD.nascimento , OLD.sexo , OLD.telefone , OLD.email ,  default);
        END$
delimiter ; 

################## 2° PROCEDURE (UPDATE) CLIENTE ###################################################
delimiter $$
CREATE PROCEDURE sp_update_cliente_cpf (p_nome varchar(45), p_cpf varchar(11) ,  p_nascimento date , p_sexo varchar (2) , p_telefone varchar (10) , p_email varchar(25)) 
begin
	update tbl_cliente
		set 
        nome = p_nome, 
		cpf = p_cpf,
		nascimento = p_nascimento,  
		sexo = p_sexo,
		telefone = p_telefone,
		email = p_email
        where cpf = p_cpf;
        select * from tbl_cliente where cpf = p_cpf;   # AQUI ESTA MOSTRANDO PRO FUNCIONARIO QUAL CLIENTE EU ATUALIZEI ==> COMO SE FOSSE UMA CONFERENCIA
end $$ 
delimiter ;

call sp_update_cliente ("458248-844","roberto","2000-08-15","M",5825,"roberto@gmail.com", 2);

#### PROCEDURE UPDATE CLIENTE POR ID 
delimiter $$
CREATE PROCEDURE sp_update_cliente (p_cpf varchar(11) ,p_nome varchar(45),  p_nascimento date , p_sexo varchar (2) , p_telefone varchar (10) , p_email varchar(25), p_id_cliente int(11)) 
begin	
    update tbl_cliente
		set 
		cpf = p_cpf,
        nome = p_nome, 
		nascimento = p_nascimento,  
		sexo = p_sexo,
		telefone = p_telefone,
		email = p_email
        where id_cliente = p_id_cliente;
        select * from tbl_cliente where id_cliente = p_id_cliente;   # AQUI ESTA MOSTRANDO PRO FUNCIONARIO QUAL CLIENTE EU ATUALIZEI ==> COMO SE FOSSE UMA CONFERENCIA
end $$ 
delimiter ;

# testando update cliente 
select * from tbl_cliente;

## AGORA Q EU FIZ O 1° UPDATE > EU TENHO Q VER SE MINHA TRIGGER FUNCIONOU > E GUARDOU O CLIENTE ANTIGO NA tbl_log_update_cliente
SELECT * FROM tbl_log_update_cliente; ## funcionou 

##### OBS > ANTES DE CRIAR A PROCEDURE(DELETE CLIENTE) DEVEMOS FAZER A TBL_PRA GUARDAR OS CLIENTES ANTIGOS Q FORAM EXCLUIDOS ( PARA UMA FUTURA CONSULTA) 
##################### CRIANDO TBL_LOG PARA GUARDAR OS USUARIOS Q FORAM DELETADOS ( CASO O FUNCIONARIO PRECISE BUSCAR OU ATUALIZAR ) ######################
CREATE TABLE tbl_log_delete_cliente(
    id_log_cliente int primary key auto_increment,
    cpf_log_cliente varchar(25) not null,
	nome_log_cliente varchar (35) not null, 
	nascimento_log_cliente date not null,  
	sexo_log_cliente char(1) not null,
	telefone_log_cliente varchar (20) not null,
	email_log_cliente varchar (30) not null,
    dt_alteracao datetime default now(),
    cliente_log_deletado boolean default 0,
    FK_log_id_delete_cliente int not null,
    constraint FK_log_id_delete_cliente foreign key (FK_log_id_delete_cliente) references tbl_cliente(id_cliente) 
);

### ################ AGORA FALTA CRIAR UMA TRIGGER Q VAI COLOCAR OS CLIENTES ANTIGOS EXCLUIDOS PARA FAZER UMA BUSCA SE PRECISAR NA TBL ACIMA 
DELIMITER $
    CREATE TRIGGER trg_clientes_excluidos_antigos after update on tbl_cliente
    FOR EACH ROW
        BEGIN
			if (select cliente_deletado from tbl_cliente where cliente_deletado = 1) then
				INSERT INTO tbl_log_delete_cliente(FK_log_id_delete_cliente , cpf_log_cliente , nome_log_cliente , nascimento_log_cliente , sexo_log_cliente , telefone_log_cliente , email_log_cliente , cliente_log_deletado , dt_alteracao)
				VALUES(OLD.id_cliente, OLD.cpf , OLD.nome , OLD.nascimento , OLD.sexo , OLD.telefone , OLD.email , NEW.cliente_deletado,  default);
            end if;
        END$
delimiter ; 

############################ ====>> (DELETE) CLIENTE PROCEDURE ##############################################
delimiter $$
CREATE PROCEDURE sp_delete_cliente_cpf (p_cpf varchar(11)) 
begin
	update tbl_cliente
		set 
		cpf = p_cpf,
        cliente_deletado = 1
        where cpf = p_cpf; 
		select * from tbl_cliente where cpf = p_cpf;  ## TBM EXIBIR ISSO ==> PRO FUNCIONARIO CONFIRMAR O USUARIO Q FOI DELETADO.
end $$ 
delimiter ;

################################# SP PROCEDURE DELETE POR ID É MELHOR 
delimiter $$
CREATE PROCEDURE sp_delete_cliente (p_id_cliente int(11)) 
begin
	## O CERTO SERIA FAZER UMA TBL DE LOG PRA GUARDAR OS USUARIOS ANTIGOS Q FOI APAGADOS ( FAZER UMA TRIGGER PRA ISSO )
	update tbl_cliente
		set 
        cliente_deletado = 1
        where id_cliente = p_id_cliente; 
		select * from tbl_cliente where id_cliente = p_id_cliente;  ## TBM EXIBIR ISSO ==> PRO FUNCIONARIO CONFIRMAR O USUARIO Q FOI DELETADO.
end $$ 
delimiter ;

# TESTANDO DELETE PROCEDURE TBL_CLIENTE 
select * from tbl_cliente;
call sp_delete_cliente("458248-844");
call sp_delete_cliente(1);
## AGORA TESTAR PARA VER SE GUARDOU O CLIENTE DELETADO NA tbl_log_delete_cliente
SELECT * FROM tbl_log_delete_cliente;

############# AGORA CRIAR A PROCEDURE PARA (BUSCAR TODOS) CLIENTES ###########################################
## CRIANDO PROCEDURE DE VISUALIZAÇÃO (PARA ENCONTRAR  UM CLIENTE ESPECIFICO POR CPF) ## ==> LEMBRANDO Q A VIEW NAO ACEITA PARAMETROS OU VARIAVEIS ENTAO POR ISSO Q FAZ A PROCEDURE
drop procedure sp_acha_usuario;

delimiter $$
CREATE PROCEDURE sp_acha_usuario_cpf(p_cpf varchar(11))
begin 
		select * from tbl_cliente where cpf = p_cpf; 
end $$
delimiter ;

############ TESTANDO VIEW DE VISUALIZAÇÃO DE UM CLIENTE POR CPF 
select * from tbl_cliente WHERE cpf = "458248-844";
CALL sp_acha_usuario("1");

###################### CRIANDO PROCEDURE DE ACHAR CLIENTE POR ID 
delimiter $$
CREATE PROCEDURE sp_acha_usuario(p_id_cliente int)
begin 
		select * from tbl_cliente where id_cliente = p_id_cliente; 
end $$
delimiter ;


######################### CRIANDO A VIEW PARA (MOSTRAR TODOS OS USUARIOS) ==> COMO SÃO MUITOS DADOS O MELHOR É FAZER POR (VIEW) ####################
#drop view vw_mostra_cliente;
CREATE VIEW vw_mostra_cliente AS
	select * from tbl_cliente;

### TESTANDO VIEW PARA ENCONTRAR (TODOS USUARIOS)    
select * from vw_mostra_cliente;

### TA TUDO FUNCIONANDO DA 1° TABELA ==> AGORA FAZER AS MESMAS COISAS COM AS OUTRAS Q FALTA OLHANDO O DIAGRAMA.. ##########
############################## CRIANDO PROCEDURE (INSERT) TBL_ANIMAL por cpf_cliente ################################
select * from tbl_animal;
desc tbl_animal;

drop procedure sp_insere_animal;
delimiter $$ 
create procedure sp_insere_animal_cpf (p_nome_animal varchar (45) , p_especie varchar(45) , p_sexo varchar(45) , p_nascimento date , p_peso int(11) , p_cpf_cliente varchar(11))
	begin
		insert into tbl_animal(nome_animal, especie , sexo  , nascimento , peso , fk_id_cliente )
			VALUES (p_nome_animal , p_especie  , p_sexo  , p_nascimento  , p_peso , (select id_cliente from tbl_cliente where cpf = p_cpf_cliente ));
    end $$
delimiter ;

select * from tbl_cliente where cpf = '458248-844';
call sp_insere_animal("totó" , "cachorro" , "m" , "1995-05-15" , 20 , "2435430-24" );

################################ PROCEDURE (INSERT) POR ID_cliente TBL_ANIMAL ############################
select * from tbl_animal;

delimiter $$ 
create procedure sp_insere_animal (p_nome_animal varchar (45) , p_especie varchar(45) , p_sexo varchar(45) , p_nascimento date , p_peso int(11) , p_id_cliente int(11))
	begin
		insert into tbl_animal(nome_animal, especie , sexo  , nascimento , peso , fk_id_cliente )
			VALUES (p_nome_animal , p_especie  , p_sexo  , p_nascimento  , p_peso , (select id_cliente from tbl_cliente where id_cliente = p_id_cliente ));
    end $$
delimiter ;

call sp_insere_animal("totó" , "cachorro" , "m" , "1995-05-15" , 20 , 1);

################# CRIANDO PROCEDURE (UPDATE) TBL_ANIMAL por id_cliente
delimiter $$ 
create procedure sp_update_animal (p_nome_animal varchar (45) , p_especie varchar(45) , p_sexo varchar(45) , p_nascimento date , p_peso int(11) , p_id_animal int(11))
	begin
		update tbl_animal
			set  
			nome_animal = p_nome_animal ,
			especie = p_especie,
			sexo = p_sexo ,
			nascimento = p_nascimento ,
			peso = p_peso  
			#fk_id_cliente = (select id_cliente from tbl_cliente where id_cliente = p_id_cliente)
            
			where id_animal = p_id_animal;
    end $$
delimiter ;

call sp_update_animal("dony", "cachorro" , "masculino ", "2020-05-02" , 15 , 2);

############### procedure (DELETE) tbL_animal por id ###############
select * from tbl_animal;

delimiter $$
CREATE PROCEDURE sp_delete_animal (p_id_animal int(11)) ## obs > nao pode ser id_cliente > pq se nao vai apagar todos os bichos do id_cliente A INTENÇÃO É APAGAR APENAS UM POR VEZ.. ENTAO TENQ SER O ID ESPECIFICO DO ANIMAL
begin
	## O CERTO SERIA FAZER UMA TBL DE LOG PRA GUARDAR OS USUARIOS ANTIGOS Q FOI APAGADOS ( FAZER UMA TRIGGER PRA ISSO )
	update tbl_animal
		set 
        animal_deletado = 1
        where id_animal = p_id_animal; 
		select * from tbl_animal where id_animal = p_id_animal;  ## TBM EXIBIR ISSO ==> PRO FUNCIONARIO CONFIRMAR O USUARIO Q FOI DELETADO.
end $$ 
delimiter ;

call sp_delete_animal(1);

########################################## CRIANDO PROCEDURE (VIEW) ACHANDO ANIMAL POR ID ####################3
delimiter $$
CREATE PROCEDURE sp_acha_animal(p_id_animal int)
begin
    (select * from tbl_animal where id_animal = p_id_animal);
end $$
delimiter ; 

call sp_acha_animal (1);

######################################## CRIANDO PROCEDURE (VIEW) PARA ACHAR TODOS ANIMAIS #############
CREATE VIEW  vw_todos_animais as
		select * from tbl_animal;
        
#### TESTANDOOO A VIEW 
select * from vw_todos_animais;

########## PROCEDURE (INSERT) TBL_FUNCIONARIO 
select* from tbl_funcionario;
delimiter $$
 create procedure sp_insere_funcionario (p_nome varchar(45) , p_cpf varchar(14))
	begin
		insert into tbl_funcionario(nome, cpf)
			VALUES (p_nome , p_cpf ) ;
    end $$
delimiter ;

## TESTANDO 
call sp_insere_funcionario ("carlos","429.482.134-20");
 
 ##################### CRIANDO PROCEDURE (UPDATE) TBL_FUNCIONARIO ==> CASO QUEIRA ATUALIZAR 
select* from tbl_funcionario;

delimiter $$ 
create procedure sp_update_funcionario (p_nome varchar (45) , p_cpf varchar(14), p_id_funcionario int(11))
	begin
		update tbl_funcionario
			set  
			nome = p_nome,
			cpf = p_cpf
			where id_funcionario = p_id_funcionario;
    end $$
delimiter ;

## TESTANDO 
CALL sp_update_funcionario("Rafael","234.144.532-14",1);

################ CRIANDO PROCEDURE (DELETE) TBL_FUNCIONARIO 
delimiter $$
CREATE PROCEDURE sp_delete_funcionario (p_id_funcionario int(11))
begin
	## O CERTO SERIA FAZER UMA TBL DE LOG PRA GUARDAR OS USUARIOS ANTIGOS Q FOI APAGADOS ( FAZER UMA TRIGGER PRA ISSO )
	update tbl_funcionario
		set 
        funcionario_deletado = 1
        where id_funcionario = p_id_funcionario;
		select * from tbl_funcionario where id_funcionario = p_id_funcionario;  ## TBM EXIBIR ISSO ==> PRO FUNCIONARIO CONFIRMAR O USUARIO Q FOI DELETADO.
end $$ 
delimiter ;

## TESTANDO 
CALL sp_delete_funcionario(1);

############## CRIANDO PROCEDURE DE ENCONTRAR FUNCIONARIO POR ID 
delimiter $$
CREATE PROCEDURE sp_acha_funcionario(p_id_funcionario int)
begin
    (select * from tbl_funcionario where id_funcionario = p_id_funcionario);
end $$
delimiter ;

## TESTANDO 
CALL sp_acha_funcionario(1);

##############3 CRIANDO VIEW PARA ENCONTRAR TODOS FUNCIONARIOS 
CREATE VIEW vw_todos_funcionarios as 
		SELECT * FROM tbl_funcionario;
        
## TESTANDO 
SELECT * FROM vw_todos_funcionarios;

################  AGORA SIM ==>  CRIANDO PROCEDURE (INSERT) TBL_COMPRA PRECISO LIGAR A COMPRA AO id_cliente e tbm  o id_funcionario q atendeu   
 SELECT * FROM tbl_compra;
desc tbl_compra;
 
 delimiter $$
 create procedure sp_insere_compra (p_valor_total decimal (7,2) , p_data_atual datetime , p_id_cliente_compra int(11), p_id_funcionario_compra int(11))
	begin
		insert into tbl_compra(valor_total, data_atual , fk_id_cliente_compra  , fk_id_funcionario_compra )
			VALUES (p_valor_total , p_data_atual  , (select id_cliente from tbl_cliente where id_cliente = p_id_cliente_compra )  , (select id_cliente from tbl_cliente where id_cliente = p_id_funcionario_compra ) ) ;
    end $$
delimiter ;

## TESTANDO
call sp_insere_compra(254.25 , NOW() , 1, 1 );

 ############### CRIANDO PROCEDURE (UPDATE) TBL_COMPRA
 drop procedure sp_update_compra;
 desc tbl_compra;

 delimiter $$ 
create procedure sp_update_compra (p_valor_total decimal (7,2) , p_data_atual datetime , p_id_cliente int(11), p_id_funcionario int(11))
	begin
		update tbl_compra
			set  
			valor_total = p_valor_total,
			data_atual = p_data_atual
            #where fk_id_cliente = (select id_cliente from tbl_cliente where id_cliente = p_id_cliente);
			where fk_id_cliente_compra = (select id_cliente from tbl_cliente where id_cliente = p_id_cliente  AND fk_id_funcionario_compra = (select id_funcionario from tbl_funcionario where id_funcionario = p_id_funcionario) );
    end $$
delimiter ;

## TESTANDO 
CALL sp_update_compra(543.25,now(),1,1);
select * from tbl_compra;

###############3 CRIANDO PROCEDURE DE (DELETE) TBL_COMPRA  
delimiter $$
CREATE PROCEDURE sp_delete_compra (p_id_compra int(11))
begin
	## O CERTO SERIA FAZER UMA TBL DE LOG PRA GUARDAR OS USUARIOS ANTIGOS Q FOI APAGADOS ( FAZER UMA TRIGGER PRA ISSO )
	update tbl_compra
		set 
        compra_deletada = 1
        where id_compra = p_id_compra;
        
		select * from tbl_compra where id_compra = p_id_compra;  ## TBM EXIBIR ISSO ==> PRO FUNCIONARIO CONFIRMAR O USUARIO Q FOI DELETADO.
end $$ 
delimiter ;

## TESTANDO 
CALL sp_delete_compra (1);

############# CRIANDO PROCEDURE (ENCONTRAR COMPRA POR ID) 
delimiter $$
CREATE PROCEDURE sp_acha_compra(p_id_cliente int) ## aqui eu posso fazer ou pelo id do cliente / funcionario / ou da propria compra
begin
    (select * from tbl_compra where fk_id_cliente_compra = p_id_cliente);
end $$
delimiter ;

## TESTANDO 
CALL sp_acha_compra(1);

################## AGORA MOSTRANDO TODAS AS COMPRAS DO CLIENTE 
CREATE VIEW vw_todas_compras as 
    select * from tbl_compra;

## TESTANDO 
SELECT * FROM vw_todas_compras;

###########################################33
#ainda não finalizado


######################################################## FALTA TERMINAR O RESTANTE DAS TABELAS 
## OBS 1° TEM A TBL_COMPRA Q É COMO SE FOSSE COMPRAS NO PET SHOP >> DE ACESSORIOS, ALIMENTOS E ETC
## OBS 2° TEM A TBL_SERVICO => Q É APENAS PARA SERVIÇOS => EX > TOSA,BANHO E ETC.. 
## OBS 3° TANTO A TBL_DE COMPRAS QUANTO A DE SERVIÇO ==> PRECISA TER UM FUNCIONARIO PRA EXECUTAR ISSO (ENTAO AS DUAS TEM A TBL_FUNCIONARIO) COMO REFERENCIA
## OBS 4° PORTANTO TENQ PRIMEIRO PREENCHER A TBL_DE_FUNCIONARIO ==> PRA DPS FAZER A TBL_DECOMPRAS E SERVIÇOS 
 #### OBS >> ANTES DE INSERIR NA TBL_COMPRAS ==> EU PRECISO ( INSERIR NA TBL_FUNCIONARIO ) (SE NAO, NAO VAI TER NENHUM FUNCIONARIO PRA PUXAR QUEM COBROU A COMPRA)
 
 ######## AGORA EU PRECISO ASSOCIAR A (TBL_servico) ==> COM A TBL_animal_servico E TBM A TBL_SERVICO_FUNCIONARIO
 ## LEMBRANDO Q EXISTE O SERVIÇO PRESTADO NO PETSHOP Q É >> BANHO , TOSA E ETC.. Q É DIFERENTE DA COMPRA Q É > RAÇÃO , BRINQUEDOS E ETC..
## primeiro eu tenho q descrever o serviço ==> dps eu falo a data q foi o serviço e dps eu falo qual funcionario fez o serviço (TUDO POR ID) 
 ## CRIANDO PROCEDURE (INSERT) NA TBL_SERVICO 
 select * from tbl_animal_servico;
 desc tbl_animal_servico;
 select * from tbl_servico;
 desc tbl_servico;
 select * from tbl_servico_funcionario;
 desc tbl_servico_funcionario;
 
 DROP PROCEDURE sp_insere_servico;
 delimiter $$
 create procedure sp_insere_servico (p_descricao varchar (45) , p_valor_servico decimal(6,2) , p_tempo_servico time , p_data_servico date ,  p_id_animal int(11) , p_id_servico int(11), p_id_funcionario int(11) )
	begin    
		# 1° PREENCHE A TABELA DE SERVIÇOS 
		insert into tbl_servico( descricao , valor_servico , tempo_servico)  
			VALUES (p_descricao , p_valor_servico , p_tempo_servico  ) ;
		
        # 2° COLOCA A DATA Q FOI O SERVIÇO E FALA QUEM FOI O ANIMAL E TBM QUAL SERVIÇO Q FOI 
		insert into tbl_animal_servico (data_servico , fk_id_animal , fk_id_servico)
			VALUES (p_data_servico , p_id_animal , p_id_servico ); ##=> DESSE JEITO EU ESCOLHO QUEM EU QUERO (dos animais e tbm dos serviços)
            
		# VALUES ((select max(id_animal) from tbl_animal) , (select max(id_servico) from tbl_servico)) ; ## esse jeito eu sempre vou considerar o ultimo id
		# 3° MOSTRA QUEM FOI Q FEZ O SERVIÇO E QUAL SERVIÇO FOI 
		insert into tbl_servico_funcionario (fk_id_servico_funcionario , fk_id_funcionario) 
			VALUES (p_id_servico , p_id_funcionario);  ## desse jeito >> escolho quem eu quero (dos servicos e dos funcionarios )
            
            #VALUES ((select max(id_servico) from tbl_servico) , (select max(id_funcionario) from tbl_funcionario)) ; ## aqui eu pego o ultimo id.. 
    end $$
delimiter ;

## testando 
CALL sp_insere_servico("banho-tosa" , 56.40 , "01:10:00" , "2021/05/15" , 1, 1, 1 );

## VENDO o resultado nas 3 tabelas pode fazer um JOIN ou exibi-las separadamente 
 select * from tbl_animal;
 select * from tbl_servico; ## 1° fez a descrição do serviço 
select * from tbl_animal_servico; ## 2° colocou a data do serviço, QUAL FOI O ANIMAL E QUAL FOI O SERVIÇO FEITO  
 select * from tbl_servico_funcionario; ## 3° definiu quem fez o serviço e qual foi o serviço 
 
######### PERCEBEU Q TIVE Q FAZER 3 INSERTS EM 3 TABELAS EM UMA PROCEDURE SÓ.. PQ AS 3 TABELAS DEPEDEM UMA DA OUTRA.. (NAO TEM COMO INSERIR UMA POR UMA) PQ ELAS PRECISAM SER INSERIDAS NA MESMA HORA
######## FAZENDO (UPDATE) TBL_serviço e as outras tbm..
## OBS > NAO TEM COMO FAZER UM UPDATE (NAS 3 TABELAS AO MESMO TEMPO) EU N SEI FAZER ISSO ==> ENTAO TENQ ATUALIZAR CADA TABELA SEPARADA

drop procedure sp_update_servico;

delimiter $$
#create procedure sp_update_servico (p_id_servico int(11) , p_descricao varchar (45) , p_valor_servico decimal(6,2) , p_tempo_servico time , p_data_servico datetime ,  p_id_funcionario int(11) )
#### OBS IMPORTANTE ==> EU NÃO POSSO ALTERAR EM UPDATE (UMA CHAVE ESTRANGEIRA, PORQUE VAI DAR ERRO) 
create procedure sp_update_servico (p_descricao varchar (45) , p_valor_servico decimal(6,2) , p_tempo_servico time , p_id_servico int(11), p_data_servico datetime)
	begin    
    ## CASO QUEIRA ATUALIZAR A TBL DE SERVIÇOS
		update tbl_servico 
			set  
			descricao = p_descricao,   
			valor_servico = p_valor_servico,
            tempo_servico = p_tempo_servico
            
            where id_servico = p_id_servico;
            
            ## CASO QUEIRA ATUALIZAR A DATA DO SERVICO 
            if p_id_servico > 0 then
            
				update tbl_animal_servico 
					set 
				data_servico = p_data_servico
				
				where fk_id_servico = p_id_servico;
				
            #(select id_servico from tbl_servico where id_servico = p_id_servico);
            #where fk_id_cliente_compra = (select id_cliente from tbl_cliente where id_cliente = p_id_cliente  AND fk_id_funcionario_compra = (select id_funcionario from tbl_funcionario where id_funcionario = p_id_funcionario) );
            #where id_servico =  (select id_servico from tbl_servico where id_servico = p_id_servico) AND  (select data_servico from tbl_animal_servico WHERE data_servico = p_data_servico) AND  (select fk_id_funcionario from tbl_servico_funcionario WHERE fk_id_funcionario = p_id_funcionario);
			#where id_servico = p_id_servico;
            end if;
    end $$
delimiter ;

## TESTANDO PRIMEIRO 
SELECT * FROM tbl_servico;  ## olha o que ja tem e dps ve o que vai mudar ########3
CALL sp_update_servico("escovação" , 34.53 , "02:13:00", 1,"2003/04/18");

SELECT * FROM tbl_animal_servico; ## olha se mudou a data.. e os IDS.. 
select * from tbl_servico_funcionario;

 #### PRONTO (ACIMA) EU FIZ O (INSERT E O UPDATE) DAS 3 TABELAS Q SE LIGAM ==> TBL_SERVICO + TBL_ANIMAL_SERVICO + TBL_SERVICO_FUNCIONARIO
 ## AGORA FALTA FAZER AS VISUALIZAÇÕES DELAS
 select * from tbl_servico_funcionario;
 select * from tbl_animal_servico;
 ###### CRIANDO VIEW DE VISUALIZAÇÃO DAS 3 TABELAS POR ID IGUAL 
 drop procedure sp_acha_servico;
 
 delimiter $$ 
 CREATE PROCEDURE sp_acha_servico (p_id_servico int(11))
 begin 
	select a.descricao, a.valor_servico, a.tempo_servico , b.fk_id_animal , b.data_servico , c.fk_id_servico_funcionario , c.fk_id_funcionario from tbl_servico a 
    JOIN tbl_animal_servico b ON b.fk_id_servico = a.id_servico
    JOIN tbl_servico_funcionario c ON c.fk_id_servico_funcionario = b.fk_id_servico

    where a.id_servico = p_id_servico and b.fk_id_servico = p_id_servico;
 end $$;
 delimiter ;
 
 ### TESTANDO 
 CALL sp_acha_servico(1);
 
 ###### AGORA MOSTRANDO AS 3 TABELAS ATRAVES DE UMA VIEW MOSTRANDO TODOS OS RESULTADOS ENCONTRADOS
 CREATE VIEW vw_todos_servicos AS
		select a.descricao, a.valor_servico, a.tempo_servico , b.fk_id_animal , b.data_servico , c.fk_id_servico_funcionario , c.fk_id_funcionario from tbl_servico a 
		JOIN tbl_animal_servico b ON b.fk_id_servico = a.id_servico
		JOIN tbl_servico_funcionario c ON c.fk_id_servico_funcionario = b.fk_id_servico;
   delimiter ;

## TESTANDO   
SELECT * FROM vw_todos_servicos;

######## FALTOU FAZER O DELETE DA TBL_SERVICO POR ID Q EU QUERO 
delimiter $$
CREATE PROCEDURE sp_delete_servico (p_id_servico int(11))
begin
	## O CERTO SERIA FAZER UMA TBL DE LOG PRA GUARDAR OS USUARIOS ANTIGOS Q FOI APAGADOS ( FAZER UMA TRIGGER PRA ISSO )
	update tbl_servico
		set 
        servico_deletado = 1
        where id_servico = p_id_servico;
		select * from tbl_servico where id_servico = p_id_servico;  ## TBM EXIBIR ISSO ==> PRO FUNCIONARIO CONFIRMAR O USUARIO Q FOI DELETADO.
end $$ 
delimiter ;

### TESTANDO 
CALL sp_delete_servico (3);




//////////////////////////////////////////////////


create database projeto;

use projeto;

CREATE TABLE tbl_cliente (
	id_cliente int(11) primary key auto_increment not null,
    nome varchar(45) not null,
    cpf varchar(14) not null,
    nascimento DATE ,
    sexo char(1) not null,
    telefone varchar(45) not null,
    email varchar(45) not null,
    cliente_deletado boolean default 0  
    );

CREATE TABLE tbl_animal (
	id_animal int (11) primary key auto_increment,
    nome_animal VARCHAr(45) not null,
    especie varchar(45) not null,
    sexo varchar(45) not null,
    nascimento date,
    peso int(11) not null,
    fk_id_cliente int(11),
    animal_deletado boolean default 0,
    constraint fk_id_cliente foreign key (fk_id_cliente) references tbl_cliente(id_cliente)
    );

CREATE TABLE tbl_servico(
	id_servico int(11) primary key auto_increment,
    descricao varchar(45) not null,
    valor_servico decimal(6,2) not null,
    tempo_servico time,
    servico_deletado boolean default 0
);

CREATE TABLE tbl_animal_servico(  
	data_servico DATETIME,
    fk_id_animal int(11),
    fk_id_servico int(11),
    
    constraint fk_id_animal foreign key (fk_id_animal) references tbl_animal (id_animal),
    constraint fk_id_servico foreign key (fk_id_servico) references tbl_servico(id_servico)
);

CREATE TABLE tbl_funcionario ( 
	id_funcionario int(11) primary key auto_increment,
    nome varchar(45) not null,
    cpf varchar(14) not null,
    funcionario_deletado boolean default 0
);

CREATE TABLE tbl_servico_funcionario (	
	fk_id_servico_funcionario int(11),
    fk_id_funcionario int(11),
    servico_deletado_funcionario boolean default 0,
    
    constraint fk_id_servico_funcionario foreign key (fk_id_servico_funcionario) references tbl_servico (id_servico),
	constraint fk_id_funcionario foreign key (fk_id_funcionario) references tbl_funcionario (id_funcionario)
);

CREATE TABLE tbl_compra(	
	id_compra int(11) primary key auto_increment,
    valor_total decimal(7,2) not null,
    data_atual DATETIME default now(),
    fk_id_cliente_compra int(11),
    fk_id_funcionario_compra int(11),
    compra_deletada boolean default 0,
    
    constraint fk_id_cliente_compra foreign key (fk_id_cliente_compra) references tbl_cliente(id_cliente),
	constraint fk_id_funcionario_compra foreign key (fk_id_funcionario_compra) references tbl_funcionario(id_funcionario)
);

############ AGORA VOU FAZER AS PROCEDURES ##################################
## (INSERT) PROCEDURE CLIENTE

delimiter $$
CREATE PROCEDURE sp_insere_cliente (p_nome varchar(45), p_cpf varchar(11) , p_nascimento date , p_sexo varchar (2) , p_telefone varchar (10) , p_email varchar(25)) 
begin
	insert into tbl_cliente(nome, cpf, nascimento, sexo, telefone, email)
		VALUES(
		p_nome, 
		p_cpf, 
		p_nascimento, 
		p_sexo , 
		p_telefone,  
		p_email 
		);
        select * from tbl_cliente where cpf = p_cpf; # AQUI ESTA MOSTRANDO PRO FUNCIONARIO, QUAL CLIENTE EU INSERI ==> COMO SE FOSSE UMA CONFERENCIA
end $$ 
delimiter ;

## TESTANDO A PROCEDURE INSERT CLIENTE
select * from tbl_cliente;

call sp_insere_cliente ("renato","458248-844","2021/05/22","M","5748-4689","silvafr@gmail.com");
call sp_insere_cliente ("julia","2435430-24","2011/08/12","F","3328-5389","julia@gmail.com");

##### ======================= ++ LOG PARA GUARDAR O UPDATE DOS CLIENTES ANTIGOS ++ ============================######### 
CREATE TABLE tbl_log_update_cliente(
    id_log_cliente int primary key auto_increment,
    cpf_log_cliente varchar(25) not null,
	nome_log_cliente varchar (35) not null, 
	nascimento_log_cliente date not null,  
	sexo_log_cliente char(1) not null,
	telefone_log_cliente varchar (20) not null,
	email_log_cliente varchar (30) not null,
    dt_alteracao datetime default now(),
    FK_log_id_cliente int not null,
    constraint FK_log_id_cliente foreign key (FK_log_id_cliente) references tbl_cliente(id_cliente) 
);

select * from tbl_log_update_cliente;

### ################ AGORA FALTA CRIAR UMA TRIGGER Q VAI COLOCAR OS CLIENTES ANTIGOS antes de ser atualizados NESSA TABELA ACIMA 
DELIMITER $
    CREATE TRIGGER trg_clientes_antigos before update on tbl_cliente
    FOR EACH ROW
        BEGIN
            INSERT INTO tbl_log_update_cliente(FK_log_id_cliente , cpf_log_cliente , nome_log_cliente , nascimento_log_cliente , sexo_log_cliente , telefone_log_cliente , email_log_cliente , dt_alteracao)
            VALUES(OLD.id_cliente, OLD.cpf , OLD.nome , OLD.nascimento , OLD.sexo , OLD.telefone , OLD.email ,  default);
        END$
delimiter ; 

################## 2° PROCEDURE (UPDATE) CLIENTE ###################################################
delimiter $$
CREATE PROCEDURE sp_update_cliente_cpf (p_nome varchar(45), p_cpf varchar(11) ,  p_nascimento date , p_sexo varchar (2) , p_telefone varchar (10) , p_email varchar(25)) 
begin
	update tbl_cliente
		set 
        nome = p_nome, 
		cpf = p_cpf,
		nascimento = p_nascimento,  
		sexo = p_sexo,
		telefone = p_telefone,
		email = p_email
        where cpf = p_cpf;
        select * from tbl_cliente where cpf = p_cpf;   # AQUI ESTA MOSTRANDO PRO FUNCIONARIO QUAL CLIENTE EU ATUALIZEI ==> COMO SE FOSSE UMA CONFERENCIA
end $$ 
delimiter ;

call sp_update_cliente ("458248-844","roberto","2000-08-15","M",5825,"roberto@gmail.com", 2);

#### PROCEDURE UPDATE CLIENTE POR ID 
delimiter $$
CREATE PROCEDURE sp_update_cliente (p_cpf varchar(11) ,p_nome varchar(45),  p_nascimento date , p_sexo varchar (2) , p_telefone varchar (10) , p_email varchar(25), p_id_cliente int(11)) 
begin	
    update tbl_cliente
		set 
		cpf = p_cpf,
        nome = p_nome, 
		nascimento = p_nascimento,  
		sexo = p_sexo,
		telefone = p_telefone,
		email = p_email
        where id_cliente = p_id_cliente;
        select * from tbl_cliente where id_cliente = p_id_cliente;   # AQUI ESTA MOSTRANDO PRO FUNCIONARIO QUAL CLIENTE EU ATUALIZEI ==> COMO SE FOSSE UMA CONFERENCIA
end $$ 
delimiter ;

# testando update cliente 
select * from tbl_cliente;

## AGORA Q EU FIZ O 1° UPDATE > EU TENHO Q VER SE MINHA TRIGGER FUNCIONOU > E GUARDOU O CLIENTE ANTIGO NA tbl_log_update_cliente
SELECT * FROM tbl_log_update_cliente; ## funcionou 

##### OBS > ANTES DE CRIAR A PROCEDURE(DELETE CLIENTE) DEVEMOS FAZER A TBL_PRA GUARDAR OS CLIENTES ANTIGOS Q FORAM EXCLUIDOS ( PARA UMA FUTURA CONSULTA) 
##################### CRIANDO TBL_LOG PARA GUARDAR OS USUARIOS Q FORAM DELETADOS ( CASO O FUNCIONARIO PRECISE BUSCAR OU ATUALIZAR ) ######################
CREATE TABLE tbl_log_delete_cliente(
    id_log_cliente int primary key auto_increment,
    cpf_log_cliente varchar(25) not null,
	nome_log_cliente varchar (35) not null, 
	nascimento_log_cliente date not null,  
	sexo_log_cliente char(1) not null,
	telefone_log_cliente varchar (20) not null,
	email_log_cliente varchar (30) not null,
    dt_alteracao datetime default now(),
    cliente_log_deletado boolean default 0,
    FK_log_id_delete_cliente int not null,
    constraint FK_log_id_delete_cliente foreign key (FK_log_id_delete_cliente) references tbl_cliente(id_cliente) 
);

### ################ AGORA FALTA CRIAR UMA TRIGGER Q VAI COLOCAR OS CLIENTES ANTIGOS EXCLUIDOS PARA FAZER UMA BUSCA SE PRECISAR NA TBL ACIMA 
DELIMITER $
    CREATE TRIGGER trg_clientes_excluidos_antigos after update on tbl_cliente
    FOR EACH ROW
        BEGIN
			if (select cliente_deletado from tbl_cliente where cliente_deletado = 1) then
				INSERT INTO tbl_log_delete_cliente(FK_log_id_delete_cliente , cpf_log_cliente , nome_log_cliente , nascimento_log_cliente , sexo_log_cliente , telefone_log_cliente , email_log_cliente , cliente_log_deletado , dt_alteracao)
				VALUES(OLD.id_cliente, OLD.cpf , OLD.nome , OLD.nascimento , OLD.sexo , OLD.telefone , OLD.email , NEW.cliente_deletado,  default);
            end if;
        END$
delimiter ; 

############################ ====>> (DELETE) CLIENTE PROCEDURE ##############################################
delimiter $$
CREATE PROCEDURE sp_delete_cliente_cpf (p_cpf varchar(11)) 
begin
	update tbl_cliente
		set 
		cpf = p_cpf,
        cliente_deletado = 1
        where cpf = p_cpf; 
		select * from tbl_cliente where cpf = p_cpf;  ## TBM EXIBIR ISSO ==> PRO FUNCIONARIO CONFIRMAR O USUARIO Q FOI DELETADO.
end $$ 
delimiter ;

################################# SP PROCEDURE DELETE POR ID É MELHOR 
delimiter $$
CREATE PROCEDURE sp_delete_cliente (p_id_cliente int(11)) 
begin
	## O CERTO SERIA FAZER UMA TBL DE LOG PRA GUARDAR OS USUARIOS ANTIGOS Q FOI APAGADOS ( FAZER UMA TRIGGER PRA ISSO )
	update tbl_cliente
		set 
        cliente_deletado = 1
        where id_cliente = p_id_cliente; 
		select * from tbl_cliente where id_cliente = p_id_cliente;  ## TBM EXIBIR ISSO ==> PRO FUNCIONARIO CONFIRMAR O USUARIO Q FOI DELETADO.
end $$ 
delimiter ;

# TESTANDO DELETE PROCEDURE TBL_CLIENTE 
select * from tbl_cliente;
call sp_delete_cliente("458248-844");
call sp_delete_cliente(1);
## AGORA TESTAR PARA VER SE GUARDOU O CLIENTE DELETADO NA tbl_log_delete_cliente
SELECT * FROM tbl_log_delete_cliente;

############# AGORA CRIAR A PROCEDURE PARA (BUSCAR TODOS) CLIENTES ###########################################
## CRIANDO PROCEDURE DE VISUALIZAÇÃO (PARA ENCONTRAR  UM CLIENTE ESPECIFICO POR CPF) ## ==> LEMBRANDO Q A VIEW NAO ACEITA PARAMETROS OU VARIAVEIS ENTAO POR ISSO Q FAZ A PROCEDURE
drop procedure sp_acha_usuario;

delimiter $$
CREATE PROCEDURE sp_acha_usuario_cpf(p_cpf varchar(11))
begin 
		select * from tbl_cliente where cpf = p_cpf; 
end $$
delimiter ;

############ TESTANDO VIEW DE VISUALIZAÇÃO DE UM CLIENTE POR CPF 
select * from tbl_cliente WHERE cpf = "458248-844";
CALL sp_acha_usuario("1");

###################### CRIANDO PROCEDURE DE ACHAR CLIENTE POR ID 
delimiter $$
CREATE PROCEDURE sp_acha_usuario(p_id_cliente int)
begin 
		select * from tbl_cliente where id_cliente = p_id_cliente; 
end $$
delimiter ;


######################### CRIANDO A VIEW PARA (MOSTRAR TODOS OS USUARIOS) ==> COMO SÃO MUITOS DADOS O MELHOR É FAZER POR (VIEW) ####################
#drop view vw_mostra_cliente;
CREATE VIEW vw_mostra_cliente AS
	select * from tbl_cliente;

### TESTANDO VIEW PARA ENCONTRAR (TODOS USUARIOS)    
select * from vw_mostra_cliente;

### TA TUDO FUNCIONANDO DA 1° TABELA ==> AGORA FAZER AS MESMAS COISAS COM AS OUTRAS Q FALTA OLHANDO O DIAGRAMA.. ##########
############################## CRIANDO PROCEDURE (INSERT) TBL_ANIMAL por cpf_cliente ################################
select * from tbl_animal;
desc tbl_animal;

drop procedure sp_insere_animal;
delimiter $$ 
create procedure sp_insere_animal_cpf (p_nome_animal varchar (45) , p_especie varchar(45) , p_sexo varchar(45) , p_nascimento date , p_peso int(11) , p_cpf_cliente varchar(11))
	begin
		insert into tbl_animal(nome_animal, especie , sexo  , nascimento , peso , fk_id_cliente )
			VALUES (p_nome_animal , p_especie  , p_sexo  , p_nascimento  , p_peso , (select id_cliente from tbl_cliente where cpf = p_cpf_cliente ));
    end $$
delimiter ;

select * from tbl_cliente where cpf = '458248-844';
call sp_insere_animal("totó" , "cachorro" , "m" , "1995-05-15" , 20 , "2435430-24" );

################################ PROCEDURE (INSERT) POR ID_cliente TBL_ANIMAL ############################
select * from tbl_animal;

delimiter $$ 
create procedure sp_insere_animal (p_nome_animal varchar (45) , p_especie varchar(45) , p_sexo varchar(45) , p_nascimento date , p_peso int(11) , p_id_cliente int(11))
	begin
		insert into tbl_animal(nome_animal, especie , sexo  , nascimento , peso , fk_id_cliente )
			VALUES (p_nome_animal , p_especie  , p_sexo  , p_nascimento  , p_peso , (select id_cliente from tbl_cliente where id_cliente = p_id_cliente ));
    end $$
delimiter ;

call sp_insere_animal("totó" , "cachorro" , "m" , "1995-05-15" , 20 , 1);

################# CRIANDO PROCEDURE (UPDATE) TBL_ANIMAL por id_cliente
delimiter $$ 
create procedure sp_update_animal (p_nome_animal varchar (45) , p_especie varchar(45) , p_sexo varchar(45) , p_nascimento date , p_peso int(11) , p_id_animal int(11))
	begin
		update tbl_animal
			set  
			nome_animal = p_nome_animal ,
			especie = p_especie,
			sexo = p_sexo ,
			nascimento = p_nascimento ,
			peso = p_peso  
			#fk_id_cliente = (select id_cliente from tbl_cliente where id_cliente = p_id_cliente)
            
			where id_animal = p_id_animal;
    end $$
delimiter ;

call sp_update_animal("dony", "cachorro" , "masculino ", "2020-05-02" , 15 , 2);

############### procedure (DELETE) tbL_animal por id ###############
select * from tbl_animal;

delimiter $$
CREATE PROCEDURE sp_delete_animal (p_id_animal int(11)) ## obs > nao pode ser id_cliente > pq se nao vai apagar todos os bichos do id_cliente A INTENÇÃO É APAGAR APENAS UM POR VEZ.. ENTAO TENQ SER O ID ESPECIFICO DO ANIMAL
begin
	## O CERTO SERIA FAZER UMA TBL DE LOG PRA GUARDAR OS USUARIOS ANTIGOS Q FOI APAGADOS ( FAZER UMA TRIGGER PRA ISSO )
	update tbl_animal
		set 
        animal_deletado = 1
        where id_animal = p_id_animal; 
		select * from tbl_animal where id_animal = p_id_animal;  ## TBM EXIBIR ISSO ==> PRO FUNCIONARIO CONFIRMAR O USUARIO Q FOI DELETADO.
end $$ 
delimiter ;

call sp_delete_animal(1);

########################################## CRIANDO PROCEDURE (VIEW) ACHANDO ANIMAL POR ID ####################3
delimiter $$
CREATE PROCEDURE sp_acha_animal(p_id_animal int)
begin
    (select * from tbl_animal where id_animal = p_id_animal);
end $$
delimiter ; 

call sp_acha_animal (1);

######################################## CRIANDO PROCEDURE (VIEW) PARA ACHAR TODOS ANIMAIS #############
CREATE VIEW  vw_todos_animais as
		select * from tbl_animal;
        
#### TESTANDOOO A VIEW 
select * from vw_todos_animais;

########## PROCEDURE (INSERT) TBL_FUNCIONARIO 
select* from tbl_funcionario;
delimiter $$
 create procedure sp_insere_funcionario (p_nome varchar(45) , p_cpf varchar(14))
	begin
		insert into tbl_funcionario(nome, cpf)
			VALUES (p_nome , p_cpf ) ;
    end $$
delimiter ;

## TESTANDO 
call sp_insere_funcionario ("carlos","429.482.134-20");
 
 ##################### CRIANDO PROCEDURE (UPDATE) TBL_FUNCIONARIO ==> CASO QUEIRA ATUALIZAR 
select* from tbl_funcionario;

delimiter $$ 
create procedure sp_update_funcionario (p_nome varchar (45) , p_cpf varchar(14), p_id_funcionario int(11))
	begin
		update tbl_funcionario
			set  
			nome = p_nome,
			cpf = p_cpf
			where id_funcionario = p_id_funcionario;
    end $$
delimiter ;

## TESTANDO 
CALL sp_update_funcionario("Rafael","234.144.532-14",1);

################ CRIANDO PROCEDURE (DELETE) TBL_FUNCIONARIO 
delimiter $$
CREATE PROCEDURE sp_delete_funcionario (p_id_funcionario int(11))
begin
	## O CERTO SERIA FAZER UMA TBL DE LOG PRA GUARDAR OS USUARIOS ANTIGOS Q FOI APAGADOS ( FAZER UMA TRIGGER PRA ISSO )
	update tbl_funcionario
		set 
        funcionario_deletado = 1
        where id_funcionario = p_id_funcionario;
		select * from tbl_funcionario where id_funcionario = p_id_funcionario;  ## TBM EXIBIR ISSO ==> PRO FUNCIONARIO CONFIRMAR O USUARIO Q FOI DELETADO.
end $$ 
delimiter ;

## TESTANDO 
CALL sp_delete_funcionario(1);

############## CRIANDO PROCEDURE DE ENCONTRAR FUNCIONARIO POR ID 
delimiter $$
CREATE PROCEDURE sp_acha_funcionario(p_id_funcionario int)
begin
    (select * from tbl_funcionario where id_funcionario = p_id_funcionario);
end $$
delimiter ;

## TESTANDO 
CALL sp_acha_funcionario(1);

##############3 CRIANDO VIEW PARA ENCONTRAR TODOS FUNCIONARIOS 
CREATE VIEW vw_todos_funcionarios as 
		SELECT * FROM tbl_funcionario;
        
CALL sp_update_compra('123','2021-11-3 21:40:53','1','1','1');
        
## TESTANDO 
SELECT * FROM vw_todos_funcionarios;

################  AGORA SIM ==>  CRIANDO PROCEDURE (INSERT) TBL_COMPRA PRECISO LIGAR A COMPRA AO id_cliente e tbm  o id_funcionario q atendeu   
 SELECT * FROM tbl_compra;
desc tbl_compra;
 
 delimiter $$
 create procedure sp_insere_compra (p_valor_total decimal (7,2) , p_data_atual datetime , p_id_cliente_compra int(11), p_id_funcionario_compra int(11))
	begin
		insert into tbl_compra(valor_total, data_atual , fk_id_cliente_compra  , fk_id_funcionario_compra )
			VALUES (p_valor_total , p_data_atual  , (select id_cliente from tbl_cliente where id_cliente = p_id_cliente_compra )  , (select id_cliente from tbl_cliente where id_cliente = p_id_funcionario_compra ) ) ;
    end $$
delimiter ;

## TESTANDO
call sp_insere_compra(254.25 , NOW() , 1, 1 );

 ############### CRIANDO PROCEDURE (UPDATE) TBL_COMPRA
 drop procedure sp_update_compra;
 desc tbl_compra;

 delimiter $$ 
create procedure sp_update_compra (p_valor_total decimal (7,2) , p_data_atual datetime , p_id_cliente int(11), p_id_funcionario int(11), p_id_compra int(11))
	begin
		update tbl_compra
			set  
			valor_total = p_valor_total,
			data_atual = p_data_atual,
            fk_id_cliente_compra = p_id_cliente,
             fk_id_funcionario_compra =  p_id_funcionario
            #where fk_id_cliente = (select id_cliente from tbl_cliente where id_cliente = p_id_cliente);
			where id_compra = p_id_compra;
    end $$
delimiter ;

## TESTANDO 
CALL sp_update_compra(543.25,now(),1,1);
select * from tbl_compra;

###############3 CRIANDO PROCEDURE DE (DELETE) TBL_COMPRA  
delimiter $$
CREATE PROCEDURE sp_delete_compra (p_id_compra int(11))
begin
	## O CERTO SERIA FAZER UMA TBL DE LOG PRA GUARDAR OS USUARIOS ANTIGOS Q FOI APAGADOS ( FAZER UMA TRIGGER PRA ISSO )
	update tbl_compra
		set 
        compra_deletada = 1
        where id_compra = p_id_compra;
        
		select * from tbl_compra where id_compra = p_id_compra;  ## TBM EXIBIR ISSO ==> PRO FUNCIONARIO CONFIRMAR O USUARIO Q FOI DELETADO.
end $$ 
delimiter ;

## TESTANDO 
CALL sp_delete_compra (1);

############# CRIANDO PROCEDURE (ENCONTRAR COMPRA POR ID) 
delimiter $$
CREATE PROCEDURE sp_acha_compra(p_id_cliente int) ## aqui eu posso fazer ou pelo id do cliente / funcionario / ou da propria compra
begin
    (select * from tbl_compra where fk_id_cliente_compra = p_id_cliente);
end $$
delimiter ;

## TESTANDO 
CALL sp_acha_compra(1);

################## AGORA MOSTRANDO TODAS AS COMPRAS DO CLIENTE 
CREATE VIEW vw_todas_compras as 
    select * from tbl_compra;

## TESTANDO 
SELECT * FROM vw_todas_compras;

###########################################33
#ainda não finalizado


######################################################## FALTA TERMINAR O RESTANTE DAS TABELAS 
## OBS 1° TEM A TBL_COMPRA Q É COMO SE FOSSE COMPRAS NO PET SHOP >> DE ACESSORIOS, ALIMENTOS E ETC
## OBS 2° TEM A TBL_SERVICO => Q É APENAS PARA SERVIÇOS => EX > TOSA,BANHO E ETC.. 
## OBS 3° TANTO A TBL_DE COMPRAS QUANTO A DE SERVIÇO ==> PRECISA TER UM FUNCIONARIO PRA EXECUTAR ISSO (ENTAO AS DUAS TEM A TBL_FUNCIONARIO) COMO REFERENCIA
## OBS 4° PORTANTO TENQ PRIMEIRO PREENCHER A TBL_DE_FUNCIONARIO ==> PRA DPS FAZER A TBL_DECOMPRAS E SERVIÇOS 
 #### OBS >> ANTES DE INSERIR NA TBL_COMPRAS ==> EU PRECISO ( INSERIR NA TBL_FUNCIONARIO ) (SE NAO, NAO VAI TER NENHUM FUNCIONARIO PRA PUXAR QUEM COBROU A COMPRA)
 
 ######## AGORA EU PRECISO ASSOCIAR A (TBL_servico) ==> COM A TBL_animal_servico E TBM A TBL_SERVICO_FUNCIONARIO
 ## LEMBRANDO Q EXISTE O SERVIÇO PRESTADO NO PETSHOP Q É >> BANHO , TOSA E ETC.. Q É DIFERENTE DA COMPRA Q É > RAÇÃO , BRINQUEDOS E ETC..
## primeiro eu tenho q descrever o serviço ==> dps eu falo a data q foi o serviço e dps eu falo qual funcionario fez o serviço (TUDO POR ID) 
 ## CRIANDO PROCEDURE (INSERT) NA TBL_SERVICO 
 select * from tbl_animal_servico;
 desc tbl_animal_servico;
 select * from tbl_servico;
 desc tbl_servico;
 select * from tbl_servico_funcionario;
 desc tbl_servico_funcionario;
 
 DROP PROCEDURE sp_insere_servico;
 delimiter $$
 create procedure sp_insere_servico (p_descricao varchar (45) , p_valor_servico decimal(6,2) , p_tempo_servico time , p_data_servico date ,  p_id_animal int(11) , p_id_servico int(11), p_id_funcionario int(11) )
	begin    
		# 1° PREENCHE A TABELA DE SERVIÇOS 
		insert into tbl_servico( descricao , valor_servico , tempo_servico)  
			VALUES (p_descricao , p_valor_servico , p_tempo_servico  ) ;
		
        # 2° COLOCA A DATA Q FOI O SERVIÇO E FALA QUEM FOI O ANIMAL E TBM QUAL SERVIÇO Q FOI 
		insert into tbl_animal_servico (data_servico , fk_id_animal , fk_id_servico)
			VALUES (p_data_servico , p_id_animal , p_id_servico ); ##=> DESSE JEITO EU ESCOLHO QUEM EU QUERO (dos animais e tbm dos serviços)
            
		# VALUES ((select max(id_animal) from tbl_animal) , (select max(id_servico) from tbl_servico)) ; ## esse jeito eu sempre vou considerar o ultimo id
		# 3° MOSTRA QUEM FOI Q FEZ O SERVIÇO E QUAL SERVIÇO FOI 
		insert into tbl_servico_funcionario (fk_id_servico_funcionario , fk_id_funcionario) 
			VALUES (p_id_servico , p_id_funcionario);  ## desse jeito >> escolho quem eu quero (dos servicos e dos funcionarios )
            
            #VALUES ((select max(id_servico) from tbl_servico) , (select max(id_funcionario) from tbl_funcionario)) ; ## aqui eu pego o ultimo id.. 
    end $$
delimiter ;

## testando 
CALL sp_insere_servico("banho-tosa" , 56.40 , "01:10:00" , "2021/05/15" , 1, 1, 1 );

## VENDO o resultado nas 3 tabelas pode fazer um JOIN ou exibi-las separadamente 
 select * from tbl_animal;
 select * from tbl_servico; ## 1° fez a descrição do serviço 
select * from tbl_animal_servico; ## 2° colocou a data do serviço, QUAL FOI O ANIMAL E QUAL FOI O SERVIÇO FEITO  
 select * from tbl_servico_funcionario; ## 3° definiu quem fez o serviço e qual foi o serviço 
 
######### PERCEBEU Q TIVE Q FAZER 3 INSERTS EM 3 TABELAS EM UMA PROCEDURE SÓ.. PQ AS 3 TABELAS DEPEDEM UMA DA OUTRA.. (NAO TEM COMO INSERIR UMA POR UMA) PQ ELAS PRECISAM SER INSERIDAS NA MESMA HORA
######## FAZENDO (UPDATE) TBL_serviço e as outras tbm..
## OBS > NAO TEM COMO FAZER UM UPDATE (NAS 3 TABELAS AO MESMO TEMPO) EU N SEI FAZER ISSO ==> ENTAO TENQ ATUALIZAR CADA TABELA SEPARADA

drop procedure sp_update_servico;

delimiter $$
#create procedure sp_update_servico (p_id_servico int(11) , p_descricao varchar (45) , p_valor_servico decimal(6,2) , p_tempo_servico time , p_data_servico datetime ,  p_id_funcionario int(11) )
#### OBS IMPORTANTE ==> EU NÃO POSSO ALTERAR EM UPDATE (UMA CHAVE ESTRANGEIRA, PORQUE VAI DAR ERRO) 
create procedure sp_update_servico (p_descricao varchar (45) , p_valor_servico decimal(6,2) , p_tempo_servico time , p_id_servico int(11), p_data_servico datetime)
	begin    
    ## CASO QUEIRA ATUALIZAR A TBL DE SERVIÇOS
		update tbl_servico 
			set  
			descricao = p_descricao,   
			valor_servico = p_valor_servico,
            tempo_servico = p_tempo_servico
            
            where id_servico = p_id_servico;
            
            ## CASO QUEIRA ATUALIZAR A DATA DO SERVICO 
            if p_id_servico > 0 then
            
				update tbl_animal_servico 
					set 
				data_servico = p_data_servico
				
				where fk_id_servico = p_id_servico;
				
            #(select id_servico from tbl_servico where id_servico = p_id_servico);
            #where fk_id_cliente_compra = (select id_cliente from tbl_cliente where id_cliente = p_id_cliente  AND fk_id_funcionario_compra = (select id_funcionario from tbl_funcionario where id_funcionario = p_id_funcionario) );
            #where id_servico =  (select id_servico from tbl_servico where id_servico = p_id_servico) AND  (select data_servico from tbl_animal_servico WHERE data_servico = p_data_servico) AND  (select fk_id_funcionario from tbl_servico_funcionario WHERE fk_id_funcionario = p_id_funcionario);
			#where id_servico = p_id_servico;
            end if;
    end $$
delimiter ;

## TESTANDO PRIMEIRO 
SELECT * FROM tbl_servico;  ## olha o que ja tem e dps ve o que vai mudar ########3
CALL sp_update_servico("escovação" , 34.53 , "02:13:00", 1,"2003/04/18");

SELECT * FROM tbl_animal_servico; ## olha se mudou a data.. e os IDS.. 
select * from tbl_servico_funcionario;

 #### PRONTO (ACIMA) EU FIZ O (INSERT E O UPDATE) DAS 3 TABELAS Q SE LIGAM ==> TBL_SERVICO + TBL_ANIMAL_SERVICO + TBL_SERVICO_FUNCIONARIO
 ## AGORA FALTA FAZER AS VISUALIZAÇÕES DELAS
 select * from tbl_servico_funcionario;
 select * from tbl_animal_servico;
 ###### CRIANDO VIEW DE VISUALIZAÇÃO DAS 3 TABELAS POR ID IGUAL 
 drop procedure sp_acha_servico;
 
 delimiter $$ 
 CREATE PROCEDURE sp_acha_servico (p_id_servico int(11))
 begin 
	select a.descricao, a.valor_servico, a.tempo_servico , b.fk_id_animal , b.data_servico , c.fk_id_servico_funcionario , c.fk_id_funcionario from tbl_servico a 
    JOIN tbl_animal_servico b ON b.fk_id_servico = a.id_servico
    JOIN tbl_servico_funcionario c ON c.fk_id_servico_funcionario = b.fk_id_servico

    where a.id_servico = p_id_servico and b.fk_id_servico = p_id_servico;
 end $$;
 delimiter ;
 
 ### TESTANDO 
 CALL sp_acha_servico(1);
 
 ###### AGORA MOSTRANDO AS 3 TABELAS ATRAVES DE UMA VIEW MOSTRANDO TODOS OS RESULTADOS ENCONTRADOS
 CREATE VIEW vw_todos_servicos AS
		select a.descricao, a.valor_servico, a.tempo_servico , b.fk_id_animal , b.data_servico , c.fk_id_servico_funcionario , c.fk_id_funcionario from tbl_servico a 
		JOIN tbl_animal_servico b ON b.fk_id_servico = a.id_servico
		JOIN tbl_servico_funcionario c ON c.fk_id_servico_funcionario = b.fk_id_servico;
   delimiter ;

## TESTANDO   
SELECT * FROM vw_todos_servicos;

######## FALTOU FAZER O DELETE DA TBL_SERVICO POR ID Q EU QUERO 
delimiter $$
CREATE PROCEDURE sp_delete_servico (p_id_servico int(11))
begin
	## O CERTO SERIA FAZER UMA TBL DE LOG PRA GUARDAR OS USUARIOS ANTIGOS Q FOI APAGADOS ( FAZER UMA TRIGGER PRA ISSO )
	update tbl_servico
		set 
        servico_deletado = 1
        where id_servico = p_id_servico;
		select * from tbl_servico where id_servico = p_id_servico;  ## TBM EXIBIR ISSO ==> PRO FUNCIONARIO CONFIRMAR O USUARIO Q FOI DELETADO.
end $$ 
delimiter ;

### TESTANDO 
CALL sp_delete_servico (3);